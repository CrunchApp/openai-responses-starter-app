
Okay, I have reviewed the analysis document (`recommendations-refactoring-analysis.md`), the conversation state documentation (`docs/conversation-state.md`), and the recent changes made to `app/recommendations/page.tsx`.

Based on this review and your feedback, here is a step-by-step plan for the next round of updates. This plan focuses on addressing the guest strategy, implementing authenticated user feedback/reset mechanisms, and cleaning up the old state management.

**Phase 1: Restore and Adapt Guest Functionality**

1.  **Update `usePathwayStore` for Guests:**
    *   Introduce state variables for guest limits: `guestPathwayGenerationCount: number` (default 0) and `maxGuestPathwayGenerations: number` (default 1).
    *   Add state to hold guest-generated pathways and programs (or ensure the existing `pathways` and `programsByPathway` state can be clearly identified/cleared for guests).
    *   Implement logic within the pathway generation action (inside the store) to check `guestPathwayGenerationCount` before proceeding for unauthenticated users. Increment the count upon successful guest generation.
    *   Refine the `clearStore` action or create a dedicated `clearGuestData` function to specifically reset guest-related state (`guestPathwayGenerationCount`, guest pathways/programs) without affecting potential future authenticated state.
2.  **Modify `PathwayExplorer.tsx` for Guest Access:**
    *   Remove the conditional rendering that completely blocks unauthenticated users.
    *   Use the `useAuth` hook to determine if the user is a guest.
    *   Check the `guestPathwayGenerationCount` from `usePathwayStore` before enabling the "Generate Pathways" button for guests.
    *   Display appropriate UI elements for guests, such as:
        *   A message indicating they are in guest mode.
        *   A call to action to sign up/log in to save progress.
        *   A message when the generation limit is reached.
    *   Ensure pathways and programs generated by guests are displayed correctly from the store.
3.  **Adjust `RecommendationsPage.tsx` for Guest Reset:**
    *   Verify the "Start Over" button's `handleReset` function correctly calls the appropriate clearing action in `usePathwayStore` (e.g., `clearGuestData` or `clearStore` adapted for guests).
    *   Ensure the redirect to `/profile-wizard` after guest reset remains correct.

**Phase 2: Implement Authenticated User Feedback and Reset**

4.  **Backend Actions (`pathway-actions.ts` or similar):**
    *   **`deletePathwayWithFeedbackAction`:**
        *   Input: `pathwayId: string`, `feedback: { reason: string; details?: string }`
        *   Logic: Locate the `education_pathways` record by `pathwayId` and `userId`. Update it to set `is_deleted = true` and store the `feedback` object in the `user_feedback` JSONB column.
        *   Return: Success/failure status.
    *   **`generateMorePathwaysAction`:**
        *   Input: `userId: string`, `existingPathways: Pathway[]`, `feedbackContext: Array<{ pathwaySummary: string; feedback: object }>` (Data from previously deleted/rated pathways)
        *   Logic:
            *   Construct a prompt for the planning agent/LLM. This prompt should include the user's profile, the `existingPathways` (non-deleted ones), and the `feedbackContext`. Use techniques similar to those in `docs/conversation-state.md` to structure the history/context if calling an API like OpenAI's directly (e.g., providing previous user feedback as context messages).
            *   Call the underlying pathway generation service/API with the enriched prompt.
            *   Save the newly generated pathways to the database, associated with the `userId`.
        *   Return: The newly generated `EducationPathway[]`.
    *   **`deleteRecommendationProgramAction`:** (Requires clarifying how programs are stored/linked)
        *   *Assumption:* Programs are stored within a JSONB field on the `education_pathways` table or fetched dynamically. If favorites are the main persistence, this action modifies the favorite status.
        *   Input: `programId: string`, `pathwayId: string` (or relevant identifiers)
        *   Logic: Remove the specific program reference or favorite status associated with the user and the pathway/program.
        *   Return: Success/failure status.
    *   **`resetPathwaysAction`:**
        *   Input: `userId: string`
        *   Logic: Find all `education_pathways` for the `userId`. Update all found records to set `is_deleted = true`. (This preserves data for potential future analysis or restoration).
        *   Return: Success/failure status.
5.  **`usePathwayStore` Actions and State:**
    *   Add store actions that call the corresponding backend actions (`deletePathway`, `generateMorePathways`, `deleteProgram`, `resetPathways`).
    *   Modify pathway fetching logic (e.g., in `syncWithSupabase` or a dedicated fetch function) to explicitly filter pathways where `is_deleted = false`.
    *   Implement state updates within the store actions to reflect changes in the UI immediately (e.g., remove pathway from `pathways` array upon deletion, append new pathways, update program lists).
    *   Consider adding a transient state to hold collected feedback before it's sent to the backend via `deletePathwayWithFeedbackAction`.
6.  **UI Implementation:**
    *   **Pathway Deletion (`EnhancedPathwayCard.tsx`):**
        *   Add a "Not Interested" / "Remove Pathway" button, visible *before* "Explore Programs" is clicked.
        *   Trigger a modal/dialog on click to collect feedback (e.g., predefined reasons via radio/checkbox, optional text input).
        *   On submission, call the `deletePathway` action in `usePathwayStore` with the pathway ID and feedback data.
    *   **Generate More Pathways (`PathwayExplorer.tsx`):**
        *   Add a "Generate More Pathways" button, visible only to authenticated users after an initial set has been generated/displayed.
        *   When clicked:
            *   Gather necessary context: current non-deleted pathways from the store, feedback associated with any pathways marked as deleted *in the store's state*.
            *   Call the `generateMorePathways` store action, passing the context.
            *   Handle loading/error states for this specific action.
    *   **Program Deletion (`ProgramCard.tsx`):**
        *   Add a "Remove" or similar button to individual program cards.
        *   On click, potentially show a confirmation, then call the `deleteProgram` store action with relevant identifiers.
    *   **Reset All Pathways (`RecommendationsPage.tsx`):**
        *   Add a "Reset Recommendations" or "Start Over" button specifically for authenticated users (perhaps near the "Edit Profile" button or within a settings dropdown).
        *   Use an `AlertDialog` for confirmation.
        *   On confirmation, call the `resetPathways` store action.
        *   Provide visual feedback (loading state, success/error message).

**Phase 3: Deprecate `useRecommendationsStore` & `actions`**

7.  **Audit Codebase:**
    *   Perform a project-wide search for `useRecommendationsStore` and `actions.ts`.
    *   Identify all components or hooks importing or using state/actions from this store.
8.  **Replace Usages:**
    *   For each identified usage, replace it with the equivalent functionality from `usePathwayStore` or `pathway-actions`.
        *   Data Reading: `recommendations`, `favoritesIds`, `isLoading`, `error` -> equivalent states in `usePathwayStore`.
        *   Actions: `toggleFavorite`, `submitFeedback`, `syncWithSupabase`, guest limit logic -> equivalent actions/logic in `usePathwayStore`.
    *   Pay close attention to ensure the guest limit functionality previously in `useRecommendationsStore` is now correctly handled by `usePathwayStore` as per Phase 1.
9.  **Remove Store:**
    *   Once all usages are confirmed to be migrated and replaced, delete the `useRecommendationsStore.ts` file.
    *   Remove any related context providers or imports if they exist elsewhere.

This phased approach allows for incremental updates, focusing first on restoring the intended guest experience, then implementing the more complex authenticated user feedback loop, and finally cleaning up the legacy store.
