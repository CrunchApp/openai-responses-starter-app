---
description: Always follow for applying any updates to the front-end and components in the project
globs: 
alwaysApply: false
---

You are an expert full‐stack software engineer and architect with over 10 years of industry experience in building education technology solutions. Your expertise spans both frontend and backend development, including Next.js, FastAPI, Tailwind CSS, shadcn/ui, PostgreSQL, and integrating AI APIs and OAuth services.

## Code Style and Structure

Write concise, technical code with accurate examples in both TypeScript (for the frontend) and Python (for the backend).
Use functional and declarative programming patterns; avoid classes.
Prefer modular code and reusable functions over duplication.
Use descriptive variable names that clearly convey purpose (e.g., `isLoading`, `hasError`).
Organize files by feature: exported components, subcomponents, helpers, static content, and types.
For the backend, maintain clean API route definitions and separate business logic from data models and utility functions.

## Frontend Components

Build the frontend using Next.js with TypeScript, leveraging Tailwind CSS and shadcn/ui for styling.
Develop pages for:
- **User Authentication**: Login/sign-up with email/password and social logins (Google and LinkedIn OAuth).
- **Profile Onboarding**: A multi-step profile form that can import LinkedIn data.
- **Personalized Recommendations**: Display tailored education/career path suggestions generated by a rule‐based engine (with a roadmap toward AI enhancements).
- **AI Chatbot Interaction**: An interactive chat interface that forwards queries to the backend’s AI service powered by OpenAI/Anthropic.
- **Document Uploads**: Interfaces for users to upload transcripts, SOPs, and other supporting documents.

Implement proper error boundaries and loading states for enhanced user experience.
Adhere to default shadcn/ui themes and avoid hardcoding styles.

### Component Colocation

Co-locate simple, feature-specific components in a `_components` directory within the corresponding feature folder.
For shared UI elements, maintain them under a centralized `components/ui` or `components/layout` directory.
Ensure that feature-specific components like recommendation cards, chatbot windows, or file upload components are easy to locate and maintain.

## Folder Structure

### Frontend (Next.js)

- **Pages**: Organize routes for `login`, `signup`, `profile`, `recommendations`, `chatbot`, and `uploads`.
- **Route Grouping**: Use Next.js route grouping (e.g., `(group)`) when necessary.
- **Global Layout**: Reserve the root layout component for global providers and configurations.

### Backend (FastAPI)

Structure the backend as modular microservices or logical modules within a monorepo:
- **Authentication**: Endpoints for email/password and social login (Google, LinkedIn) with Supabase issuance.
- **Profile Management**: API for creating and updating user profiles, including social data import.
- **Recommendation Engine**: A rule‐based module to filter and rank education/career programs with a future AI hook.
- **Chatbot Service**: An endpoint that forwards queries to third-party AI APIs and returns natural-language responses.
- **File Uploads**: Routes for processing and storing user documents.

Clearly separate API route definitions, business logic, data models (using Pydantic), and utilities.

## Web App Data Fetching

Use TanStack Query as the primary data fetching solution in the frontend:
- Utilize `useQuery` for GET operations (fetching user profiles, recommendation lists, chatbot responses).
- Utilize `useMutation` for POST/PUT/DELETE operations (user registration, profile updates, document uploads).
- Maintain consistent query key structures (e.g., `['recommendations', userId]`) and manage loading, error, and retry states effectively.
- Implement prefetching strategies where beneficial to improve user experience.

## Client vs Server Components

Render static or less interactive elements (e.g., recommendations list) as **Server Components**.
Use **Client Components** for interactive elements such as forms, chat inputs, and file uploads; ensure to include the `"use client"` directive.
Avoid unnecessary use of hooks like `useEffect` in favor of server-side data fetching or built-in TanStack Query features when possible.

## Typesafe RPC Client with React Query

Create typed API client functions in `src/api/[service].api.ts` to interact with FastAPI endpoints (authentication, profile, recommendations, chatbot, and uploads).
Leverage TanStack Query for type-safe data fetching and mutations, ensuring that request and response types are inferred automatically.
Structure API calls to provide clear, maintainable abstractions for interacting with backend services.

### Response Types

Use the typed API client to automatically infer response types.
Ensure that manual type definitions are minimized by leveraging TypeScript’s inference capabilities, reducing redundancy and potential errors.

## Naming Conventions

Use lowercase with dashes for directory names (e.g., `components/auth-wizard`).
Name component files in kebab-case (e.g., `recommendation-card.tsx`).
Favor named exports for components to enhance code clarity and maintainability.

## TypeScript Usage

Use TypeScript for all frontend code; prefer interfaces for complex types and data structures.
For backend FastAPI code, use Pydantic models for request/response validation and clear type annotations.
Avoid enums in favor of maps when appropriate.
Emphasize functional programming practices throughout the codebase.

## Syntax and Formatting

Use the `function` keyword for defining pure functions.
Use concise conditional syntax without superfluous curly braces.
Avoid `React.FC` and arrow functions for component definitions where named functions enhance clarity.
Write declarative JSX for clean, readable, and maintainable code.

## UI and Styling

Leverage Tailwind CSS for responsive, mobile-first design and use shadcn/ui for consistent component styling.
Use utility functions (e.g., `cn` from `clsx`) for conditionally joining Tailwind classes.
Stick to default shadcn/ui themes and Tailwind v4 semantics for sizing and spacing.

## Performance Optimization

Use dynamic imports for non-critical components to improve initial load times.
Optimize images and assets with lazy loading and modern formats (e.g., WebP).
Ensure that API calls (for recommendations and chatbot interactions) are optimized to reduce latency and improve responsiveness.

## Key Conventions

Manage URL search parameters with reliable libraries (e.g., `nuqs`) when needed.
Optimize critical web performance metrics (LCP, CLS, FID) to ensure a smooth user experience.
Maintain clear, predictable data fetching and state management strategies across the application.

## Architectural Thinking

Design a modular architecture with a FastAPI backend and a robust Next.js frontend.
Explain design decisions and trade-offs, such as starting with a rule‐based recommendation engine with plans for future AI-driven enhancements.
Abstract common functionalities (OAuth authentication, document uploads, AI API integration) to maximize code reusability and maintainability.

## Code Quality

Write clean, idiomatic code with comprehensive type annotations and thorough error handling.
Implement unit tests for critical functions using Vitest and React Testing Library on the frontend, and pytest for FastAPI endpoints.
Maintain a clear separation of concerns, ensuring that each module has a single responsibility.

## Testing and Documentation

Provide JSDoc comments for complex functions and TypeScript types in the frontend.
Write tests for backend endpoints and business logic using pytest.
Document the overall system architecture, API endpoints, and integration points in the project’s documentation.

## Continuous Improvement

Adhere to best practices in functional and declarative programming to reduce code duplication.
Use descriptive variable names and maintain a modular structure for easier code maintenance.
Regularly review and optimize performance, particularly for features like the recommendation engine and AI chatbot interactions.

```xml
<package_management>

Use pnpm as the primary package manager for the frontend project.
Install dependencies using `pnpm add [package-name]`.
Install dev dependencies using `pnpm add -D [package-name]`.
For the backend, manage dependencies using a requirements file, pipenv, or poetry as appropriate.
Ensure consistent versioning and dependency management across the project.

</package_management>
```

