
Okay, let's break down the current recommendation generation flow and map out a refactoring plan to achieve the desired two-step process (Pathways -> Programs).

**Analysis of Current Flow**

1.  **Trigger:** The process starts on the `RecommendationsPage` when the user either has no existing recommendations or clicks "Generate More". The `fetchRecommendations` function (local to the page) is called.
2.  **Action Call:** `fetchRecommendations` calls the `generateRecommendations` server action in `app/recommendations/actions.ts`.
3.  **API Route Call:** `generateRecommendations` calls `fetchRecommendationsFromAPI` (also in `actions.ts`), which makes a POST request to the `/api/recommendations/generate/route.ts` endpoint, sending the `userProfile`.
4.  **Backend API (`/api/recommendations/generate/route.ts`):** This is the core of the current *combined* generation:
    *   **Planning Agent:** It first calls `generateEducationPathways` (using OpenAI `o3-mini`) to create 4 potential pathway suggestions based on the user profile. Each pathway includes a generated `queryString`.
    *   **Program Research Agent:** It then immediately calls `researchSpecificPrograms`, passing the generated pathways.
        *   `researchSpecificPrograms` loops through (up to 3) pathways.
        *   For *each* pathway, it constructs a detailed query (`constructDetailedQuery`) and calls `searchProgramsWithPerplexityAPI` (in `perplexity-integration.ts`).
    *   **Perplexity Integration (`perplexity-integration.ts`):**
        *   `searchProgramsWithPerplexityAPI` calls `callPerplexityApi` (using Perplexity `sonar-pro` with web search).
        *   Includes fallback logic to OpenAI (`gpt-4o`) via `fallbackToOpenAI` if Perplexity fails.
        *   The raw text result is then parsed and structured using `parsePerplexityResponse`, which *itself* calls OpenAI (`gpt-4o-mini`) to extract JSON. This parser also calculates initial match scores/rationales.
    *   **Enhancement:** Back in `route.ts`, `enhanceRecommendationsWithMatchScores` potentially refines these scores (might be redundant).
    *   **Response:** The API route returns a flat list of `RecommendationProgram` objects combined from all researched pathways.
5.  **Action Processing (`actions.ts`):** `generateRecommendations` receives the flat list.
    *   If the user is authenticated, it calls `saveRecommendationsBatch` (`supabase-helpers.ts`).
6.  **Database & Vector Store Sync (`supabase-helpers.ts` & `vector-store-helpers.ts`):**
    *   `saveRecommendationsBatch`: Iterates through programs, calls `store_recommendation` Supabase RPC for each (saving to `programs` & `recommendations` tables).
    *   After DB save, calls `syncRecommendationsToVectorStore`.
    *   `syncRecommendationsToVectorStore`: Creates JSON files for each saved recommendation, uploads them via `/api/vector_stores/upload_file`, saves file info to `recommendation_files` table, and adds files to the user's vector store via `/api/vector_stores/add_files_batch`.
7.  **Frontend Update (`RecommendationsPage` & `useRecommendationsStore`):**
    *   The action returns the results to the page.
    *   `processRecommendationResults` updates the Zustand store (`useRecommendationsStore`) with the flat list of recommendations using `setRecommendations` or `appendRecommendations`.
    *   The UI displays the flat list.

**Refactoring Plan: Separating Pathways and Programs**

This plan involves significant changes across the frontend, backend actions, database schema, and potentially AI logic handling.

**Phase 1: Data Model & Database Changes (Supabase)**

1.  **New Table: `education_pathways`**
    *   Purpose: Store the generated pathways for each user.
    *   Columns:
        *   `id` (UUID, PK)
        *   `user_id` (UUID, FK -> `auth.users.id`, Indexed)
        *   `created_at` (Timestamp)
        *   `title` (Text)
        *   `qualification_type` (Text)
        *   `field_of_study` (Text)
        *   `subfields` (Text Array)
        *   `target_regions` (Text Array)
        *   `budget_range_usd` (JSONB, e.g., `{ "min": 10000, "max": 30000 }`) - *Standardize currency*
        *   `duration_months` (JSONB, e.g., `{ "min": 12, "max": 24 }`)
        *   `alignment_rationale` (Text) - Explanation from the AI.
        *   `alternatives` (Text Array)
        *   `query_string` (Text) - The search query generated by the Planning Agent for this pathway.
        *   `user_feedback` (JSONB, Nullable) - Store user input (e.g., `{ liked: true/false, reason: "...", comments: "..." }`).
        *   `is_explored` (Boolean, Default: `false`) - Flag if programs have been generated.
        *   `last_explored_at` (Timestamp, Nullable)
2.  **Modify Table: `recommendations`**
    *   Purpose: Link specific program recommendations back to their originating pathway.
    *   Add Column: `pathway_id` (UUID, FK -> `education_pathways.id`, Nullable, Indexed).
3.  **New/Modified Supabase Functions (RPCs):**
    *   `create_education_pathways(p_user_id UUID, p_pathways JSONB[])`: Stores a batch of pathways.
    *   `get_user_pathways(p_user_id UUID)`: Fetches pathways for a user.
    *   `update_pathway_feedback(p_pathway_id UUID, p_feedback JSONB)`: Updates user feedback on a pathway.
    *   `update_pathway_explored_status(p_pathway_id UUID, p_is_explored BOOLEAN)`: Updates the explored flag.
    *   Modify `store_recommendation`: Add `p_pathway_id UUID` parameter and insert it into the `recommendations` table.
    *   Modify `get_user_recommendations`: Potentially add grouping by `pathway_id` or create a new `get_recommendations_for_pathway(p_pathway_id UUID)`.
    *   Modify `deleteUserRecommendations`: Needs logic to potentially delete pathways *and* their associated recommendations/files, or just recommendations based on user choice.

**Phase 2: Backend Actions & API Refactoring**

1.  **Isolate Planning Agent:** Move `generateEducationPathways` logic from the current API route into a reusable function, potentially in `lib/ai/planningAgent.ts`.
2.  **New Action: `generatePathwaysAction` (`actions.ts`)**
    *   Takes `userId`.
    *   Calls the isolated `generateEducationPathways` function.
    *   Calls the new `create_education_pathways` Supabase RPC to save the results.
    *   Returns the generated pathways (with their new DB IDs) to the frontend.
3.  **Isolate Program Research Agent:** Move `researchSpecificPrograms`, `constructDetailedQuery`, and its dependencies (`searchProgramsWithPerplexityAPI`, etc.) into a reusable module (e.g., `lib/ai/programResearchAgent.ts`).
    *   Modify `researchSpecificPrograms` to accept a *single* pathway object (fetched from DB) and optional `user_feedback` from that pathway. It should only process this one pathway.
    *   Consider how `user_feedback` refines the process (e.g., modify `constructDetailedQuery` or add post-filtering).
4.  **New Action: `generateProgramsForPathwayAction` (`actions.ts`)**
    *   Takes `userId`, `pathwayId`, and optional `pathwayFeedback`.
    *   Fetches the specific pathway details (including `query_string`) from Supabase using `pathwayId`.
    *   Calls the isolated `researchSpecificPrograms` function with the pathway data and feedback.
    *   Calls a modified `saveProgramsBatch` (adapted from `saveRecommendationsBatch`), passing the `pathwayId` for linking.
    *   Calls a modified `syncProgramsToVectorStore` (see below).
    *   Calls `update_pathway_explored_status` RPC.
    *   Returns the list of generated `RecommendationProgram` objects for *that specific pathway*.
5.  **Refactor `supabase-helpers.ts`:**
    *   Implement helpers for the new RPCs (`create_education_pathways`, `get_user_pathways`, etc.).
    *   Modify `saveRecommendationsBatch` -> `saveProgramsBatch` to require `pathwayId`.
    *   Modify `fetchUserRecommendations` based on the chosen retrieval strategy (grouped or pathway-specific).
    *   Update `deleteUserRecommendations` and potentially add `deleteUserPathways`.
6.  **Refactor `vector-store-helpers.ts`:**
    *   Modify `syncRecommendationsToVectorStore` -> `syncProgramsToVectorStore`.
    *   Require `pathwayId` as input.
    *   Include `pathwayId` within the JSON content saved to the vector store file. This allows the chat assistant to know the context/origin of a program.
    *   Modify file naming convention (e.g., `recommendation_${userId}_${pathwayId}_${programId}.json`).
    *   Update `syncSingleRecommendationToVectorStore` similarly.
    *   Ensure `cleanupRecommendationFiles` and related functions correctly handle file deletion based on `recommendationId`.
7.  **Remove Old API Route:** Delete `/api/recommendations/generate/route.ts`.

**Phase 3: Frontend State & UI Refactoring**

1.  **Zustand Store (`useRecommendationsStore.ts`):**
    *   Add state: `pathways: Pathway[] = []` (Define `Pathway` type based on DB schema).
    *   Modify state: `recommendations: { [pathwayId: string]: RecommendationProgram[] } = {}`. Store programs grouped by their pathway ID.
    *   Add actions: `setPathways(pathways: Pathway[])`, `addProgramsToPathway(pathwayId: string, programs: RecommendationProgram[])`, `updatePathwayFeedback(pathwayId: string, feedback: any)`, `clearPathways()`.
    *   Refactor existing actions (`setRecommendations`, `appendRecommendations` removed/replaced, `toggleFavorite`, `submitFeedback` need update to work with nested structure, `resetState`, `clearStore` updated).
    *   Modify `syncWithSupabase`: Should fetch both pathways (`get_user_pathways`) and *all* existing recommendations grouped by pathway (e.g., modify `get_user_recommendations` or call `get_recommendations_for_pathway` for each explored pathway).
2.  **`RecommendationsPage.tsx`:**
    *   **Initial Load:** Check for `pathways` in the store. If empty and profile complete, show "Generate Pathways". If pathways exist, display them.
    *   **Pathway Generation:** Button calls `generatePathwaysAction`. Update store via `setPathways`. Show loading state.
    *   **Pathway Display:** Render pathway cards using data from `store.pathways`. Each card needs:
        *   Pathway details (title, description, etc.).
        *   "Explore Programs" button (disabled if `is_explored` is true or currently loading programs for this pathway).
        *   Feedback mechanism (optional for now).
    *   **Program Generation:** "Explore Programs" button calls `generateProgramsForPathwayAction` with `pathway.id`. Show loading indicator *within that specific pathway card*.
    *   **Program Display:** When programs return for a pathway, update store via `addProgramsToPathway`. Render the `RecommendationProgram` list nested inside the corresponding pathway card (e.g., within an `Accordion` or collapsible section). Use existing card logic for program details, favorites, feedback, etc.
    *   **State Handling:** Manage loading/error states distinctly for pathway generation vs. program generation per pathway.
    *   **Reset:** `handleResetRecommendations` needs to decide if it also clears pathways or just the programs within them. The "Start Over" (`handleReset`) should clear everything (profile, pathways, programs, vector store).

**Phase 4: Cleanup & Considerations**

1.  **Redundancy:** Remove the old `generateRecommendations`, `fetchRecommendationsFromAPI` actions and the `/api/recommendations/generate` route.
2.  **Match Scores:** Consolidate match score calculation. Doing it during the parsing step (`parsePerplexityResponse`) seems sufficient; remove `enhanceRecommendationsWithMatchScores`.
3.  **Error Handling:** Ensure robust error reporting for pathway generation failures and individual program generation failures.
4.  **Guest Experience:** How are pathways handled for guests? Stored locally? Limited? This flow leans more towards authenticated users due to DB persistence. A guest might only get to generate pathways once, and exploring programs might require sign-up.
5.  **Performance:** Fetching programs per pathway might feel more responsive than one large generation, but involves more clicks. Fetching all existing programs grouped by pathway on load needs an efficient query.

This refactoring separates the concerns, gives users more control, allows for pathway-specific feedback, and structures the data more logically for both the database and the vector store context. It's a significant change but aligns better with a guided user experience.
